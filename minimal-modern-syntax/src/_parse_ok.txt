foo

foo

---

Foo

"Foo"

---

{ foo, Foo }

{
  foo
  "Foo"
}

---

f(g(), h(Bar), Baz)

(f
  (g)
  (h
    "Bar")
  "Baz")

---

f(g(x)(y)())

(f
  (((g
    x)
    y)))

---

f(x) foo g(y)

(foo
  (f
    x)
  (g
    y))

---

(a * b) + (c * d)

(+
  (*
    a
    b)
  (*
    c
    d))

---

if (x == y) {
  foo()
} else: {
  Bar
}

(if
  (==
    x
    y)
  {
    (foo)
  }
  [
    (
      "else"
      {
        "Bar"
      }
    )
  ])

---

if (x == y) (foo [Bar] baz: Qux) else: Foobar

((if
  (==
    x
    y))
  (foo
    [
      "Bar"
    ]
    [
      (
        "baz"
        "Qux"
      )
    ])
  [
    (
      "else"
      "Foobar"
    )
  ])

---

foo = Foo
id = (x => { x })
x = id(id(foo))

(=
  foo
  "Foo")
(=
  id
  (=>
    x
    {
      x
    }))
(=
  x
  (id
    (id
      foo)))

---

f(x, y) = {
  match (Pair(x, y)) [
    Pair(x, x) => { x }
    Pair(x, y) => { Mismatch }
    x => { InvalidPair(x) }
  ]
}

(=
  (f
    x
    y)
  {
    (match
      ("Pair"
        x
        y)
      [
        (=>
          ("Pair"
            x
            x)
          {
            x
          })
        (=>
          ("Pair"
            x
            y)
          {
            "Mismatch"
          })
        (=>
          x
          {
            ("InvalidPair"
              x)
          })
      ])
  })

---

if (x == y) { print(Equal) } else: { print(NotEqual) }
if (x == Foo) {} else: {}

(if
  (==
    x
    y)
  {
    (print
      "Equal")
  }
  [
    (
      "else"
      {
        (print
          "NotEqual")
      }
    )
  ])
(if
  (==
    x
    "Foo")
  {}
  [
    (
      "else"
      {}
    )
  ])

---

// Foo
Foo(Bar)// this is a comment // comment
Baz(Qux)//

("Foo"
  "Bar")
("Baz"
  "Qux")

---

Foo("bar baz")

("Foo"
  "bar baz")

---

X + Y + Z

(+
  (+
    "X"
    "Y")
  "Z")

---

()

()

---

({a}, {b})

(
  {
    a
  }
  {
    b
  }
)

---

foo: bar

(
  "foo"
  bar
)

---

[foo: bar, baz: qux]

[
  (
    "foo"
    bar
  )
  (
    "baz"
    qux
  )
]

---

{
  // = could be a macro:
  f = (x, y) {
    // recursive call:
    f(x, y)
  }
}

{
  (=
    f
    (
      x
      y
    )
    {
      (f
        x
        y)
    })
}